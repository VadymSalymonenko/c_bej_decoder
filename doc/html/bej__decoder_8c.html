<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MyProject: src/bej_decoder.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MyProject
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bej_decoder.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="bej__decoder_8h_source.html">bej_decoder.h</a>&quot;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bej_decoder.c:</div>
<div class="dyncontent">
<div class="center"><img src="bej__decoder_8c__incl.png" border="0" usemap="#asrc_2bej__decoder_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1b08e23240c0ddf82dcf069f3fde61bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a1b08e23240c0ddf82dcf069f3fde61bd">advance_ptr</a> (unsigned char **data, int bytes_to_advance)</td></tr>
<tr class="memdesc:a1b08e23240c0ddf82dcf069f3fde61bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the position of a pointer.  <a href="bej__decoder_8c.html#a1b08e23240c0ddf82dcf069f3fde61bd">More...</a><br /></td></tr>
<tr class="separator:a1b08e23240c0ddf82dcf069f3fde61bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f5c0fbab108d820ddfc5a60ebea2fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a54f5c0fbab108d820ddfc5a60ebea2fa">read_int_const_ptr</a> (unsigned char *data, int length)</td></tr>
<tr class="memdesc:a54f5c0fbab108d820ddfc5a60ebea2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an integer from data.  <a href="bej__decoder_8c.html#a54f5c0fbab108d820ddfc5a60ebea2fa">More...</a><br /></td></tr>
<tr class="separator:a54f5c0fbab108d820ddfc5a60ebea2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dd2a2f04ea263c2e66861676eacde5"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a15dd2a2f04ea263c2e66861676eacde5">read_str_const_ptr</a> (unsigned char *data, int length)</td></tr>
<tr class="memdesc:a15dd2a2f04ea263c2e66861676eacde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string from data.  <a href="bej__decoder_8c.html#a15dd2a2f04ea263c2e66861676eacde5">More...</a><br /></td></tr>
<tr class="separator:a15dd2a2f04ea263c2e66861676eacde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa524f98bef13dd63aa015bda5a84c3d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#aa524f98bef13dd63aa015bda5a84c3d6">read_int</a> (unsigned char **data, int length)</td></tr>
<tr class="memdesc:aa524f98bef13dd63aa015bda5a84c3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an integer from data.  <a href="bej__decoder_8c.html#aa524f98bef13dd63aa015bda5a84c3d6">More...</a><br /></td></tr>
<tr class="separator:aa524f98bef13dd63aa015bda5a84c3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1e449bf8ab0198a1dc7922136510ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a9a1e449bf8ab0198a1dc7922136510ea">read_length_and_get_int</a> (unsigned char **data)</td></tr>
<tr class="memdesc:a9a1e449bf8ab0198a1dc7922136510ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the length of an integer from data, then reads the integer.  <a href="bej__decoder_8c.html#a9a1e449bf8ab0198a1dc7922136510ea">More...</a><br /></td></tr>
<tr class="separator:a9a1e449bf8ab0198a1dc7922136510ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b3d5c96b1e9ebeddbcdb992eb0678"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a791b3d5c96b1e9ebeddbcdb992eb0678">read_str</a> (unsigned char **data, int length)</td></tr>
<tr class="memdesc:a791b3d5c96b1e9ebeddbcdb992eb0678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string from data.  <a href="bej__decoder_8c.html#a791b3d5c96b1e9ebeddbcdb992eb0678">More...</a><br /></td></tr>
<tr class="separator:a791b3d5c96b1e9ebeddbcdb992eb0678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0d2c4f1ff21290a6e91538ece132c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a6e0d2c4f1ff21290a6e91538ece132c4">allocate_sflv_array</a> (struct <a class="el" href="structbej__node.html">bej_node</a> *root)</td></tr>
<tr class="memdesc:a6e0d2c4f1ff21290a6e91538ece132c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for an array of pointers to SFLV structures.  <a href="bej__decoder_8c.html#a6e0d2c4f1ff21290a6e91538ece132c4">More...</a><br /></td></tr>
<tr class="separator:a6e0d2c4f1ff21290a6e91538ece132c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3527bde59a731fd8c6fa4358caac455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#ad3527bde59a731fd8c6fa4358caac455">free_sflv_array</a> (struct <a class="el" href="structbej__node.html">bej_node</a> *root)</td></tr>
<tr class="memdesc:ad3527bde59a731fd8c6fa4358caac455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory of an array of pointers to SFLV structures.  <a href="bej__decoder_8c.html#ad3527bde59a731fd8c6fa4358caac455">More...</a><br /></td></tr>
<tr class="separator:ad3527bde59a731fd8c6fa4358caac455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512b0358b77851241f832bcbc707103b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a512b0358b77851241f832bcbc707103b">parse_sflv_recursion</a> (struct <a class="el" href="structbej__node.html">bej_node</a> *parent, unsigned char **data, size_t data_len)</td></tr>
<tr class="memdesc:a512b0358b77851241f832bcbc707103b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively parses data into a SFLV structure.  <a href="bej__decoder_8c.html#a512b0358b77851241f832bcbc707103b">More...</a><br /></td></tr>
<tr class="separator:a512b0358b77851241f832bcbc707103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad983441c699b8261b6bc1413a0cd0184"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#ad983441c699b8261b6bc1413a0cd0184">parse_sflv_init</a> (unsigned char *data, size_t data_len)</td></tr>
<tr class="memdesc:ad983441c699b8261b6bc1413a0cd0184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the parsing of data into a SFLV structure.  <a href="bej__decoder_8c.html#ad983441c699b8261b6bc1413a0cd0184">More...</a><br /></td></tr>
<tr class="separator:ad983441c699b8261b6bc1413a0cd0184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0f831d096531abbe7a329a57a80e24"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a6b0f831d096531abbe7a329a57a80e24">create_dynamic_string</a> (void)</td></tr>
<tr class="memdesc:a6b0f831d096531abbe7a329a57a80e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new dynamic string.  <a href="bej__decoder_8c.html#a6b0f831d096531abbe7a329a57a80e24">More...</a><br /></td></tr>
<tr class="separator:a6b0f831d096531abbe7a329a57a80e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d254279f4e08699cf3ca9b18ea2cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#ad5d254279f4e08699cf3ca9b18ea2cc3">check_realloc</a> (struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *str, size_t additional_length)</td></tr>
<tr class="memdesc:ad5d254279f4e08699cf3ca9b18ea2cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks and reallocates memory for the dynamic string.  <a href="bej__decoder_8c.html#ad5d254279f4e08699cf3ca9b18ea2cc3">More...</a><br /></td></tr>
<tr class="separator:ad5d254279f4e08699cf3ca9b18ea2cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84809574808f29af561ff2a5b76fba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#ae84809574808f29af561ff2a5b76fba4">append_string</a> (struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *str, const char *append_str)</td></tr>
<tr class="memdesc:ae84809574808f29af561ff2a5b76fba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a string to the dynamic string.  <a href="bej__decoder_8c.html#ae84809574808f29af561ff2a5b76fba4">More...</a><br /></td></tr>
<tr class="separator:ae84809574808f29af561ff2a5b76fba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc21842284e7153d39958ca97c2da8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#abbc21842284e7153d39958ca97c2da8b">append_char</a> (struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *str, char c)</td></tr>
<tr class="memdesc:abbc21842284e7153d39958ca97c2da8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a character to the dynamic string.  <a href="bej__decoder_8c.html#abbc21842284e7153d39958ca97c2da8b">More...</a><br /></td></tr>
<tr class="separator:abbc21842284e7153d39958ca97c2da8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608dc77b7ed16577b157e7bb774537b2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a608dc77b7ed16577b157e7bb774537b2">get_key_from_dictionary</a> (struct <a class="el" href="structbej__node.html">bej_node</a> *node, unsigned char *schema_dictionary)</td></tr>
<tr class="memdesc:a608dc77b7ed16577b157e7bb774537b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the key from the dictionary for the given node.  <a href="bej__decoder_8c.html#a608dc77b7ed16577b157e7bb774537b2">More...</a><br /></td></tr>
<tr class="separator:a608dc77b7ed16577b157e7bb774537b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5297aa4020b05578d17cb40783c5f140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a5297aa4020b05578d17cb40783c5f140">add_node_key_to_str</a> (struct <a class="el" href="structbej__node.html">bej_node</a> *node, struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *str, unsigned char *schema_dictionary)</td></tr>
<tr class="memdesc:a5297aa4020b05578d17cb40783c5f140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the key of a node to the dynamic string.  <a href="bej__decoder_8c.html#a5297aa4020b05578d17cb40783c5f140">More...</a><br /></td></tr>
<tr class="separator:a5297aa4020b05578d17cb40783c5f140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53929b18f3c3e40299e1269b0e6ec3f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a53929b18f3c3e40299e1269b0e6ec3f5">add_tab</a> (struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *str, int count)</td></tr>
<tr class="memdesc:a53929b18f3c3e40299e1269b0e6ec3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds tabs to the dynamic string.  <a href="bej__decoder_8c.html#a53929b18f3c3e40299e1269b0e6ec3f5">More...</a><br /></td></tr>
<tr class="separator:a53929b18f3c3e40299e1269b0e6ec3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ac21e49ede2df99d05d62778013958"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a64ac21e49ede2df99d05d62778013958">parse_bej_node_to_str_recursion</a> (struct <a class="el" href="structbej__node.html">bej_node</a> *node, struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *str, char parse_type, char recursion_depth, unsigned char *schema_dictionary)</td></tr>
<tr class="memdesc:a64ac21e49ede2df99d05d62778013958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively parses a BEJ node and its children to a string.  <a href="bej__decoder_8c.html#a64ac21e49ede2df99d05d62778013958">More...</a><br /></td></tr>
<tr class="separator:a64ac21e49ede2df99d05d62778013958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d8ca7465a9dc756c33c2684f4807bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a11d8ca7465a9dc756c33c2684f4807bc">parse_bej_node_to_str</a> (struct <a class="el" href="structbej__node.html">bej_node</a> *root, struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *str, unsigned char *schema_dictionary)</td></tr>
<tr class="memdesc:a11d8ca7465a9dc756c33c2684f4807bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the parsing of the BEJ tree to a string.  <a href="bej__decoder_8c.html#a11d8ca7465a9dc756c33c2684f4807bc">More...</a><br /></td></tr>
<tr class="separator:a11d8ca7465a9dc756c33c2684f4807bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1651e23462cc0755ba94e0d4673a4ce8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bej__decoder_8c.html#a1651e23462cc0755ba94e0d4673a4ce8">decode_bej</a> (unsigned char *data, size_t data_len, unsigned char *schema_dictionary, size_t schema_dictionary_len, const unsigned char *annotation_dictionary, size_t annotation_dictionary_len)</td></tr>
<tr class="memdesc:a1651e23462cc0755ba94e0d4673a4ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes BEJ data into a string.  <a href="bej__decoder_8c.html#a1651e23462cc0755ba94e0d4673a4ce8">More...</a><br /></td></tr>
<tr class="separator:a1651e23462cc0755ba94e0d4673a4ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5297aa4020b05578d17cb40783c5f140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5297aa4020b05578d17cb40783c5f140">&#9670;&nbsp;</a></span>add_node_key_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_node_key_to_str </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>schema_dictionary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the key of a node to the dynamic string. </p>
<p>This function retrieves the key for the given node from the schema dictionary and appends it to the dynamic string with formating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A pointer to the BEJ node. </td></tr>
    <tr><td class="paramname">str</td><td>A pointer to the dynamic string. </td></tr>
    <tr><td class="paramname">schema_dictionary</td><td>A pointer to the schema dictionary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53929b18f3c3e40299e1269b0e6ec3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53929b18f3c3e40299e1269b0e6ec3f5">&#9670;&nbsp;</a></span>add_tab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_tab </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds tabs to the dynamic string. </p>
<p>This function adds a specified number of tabs to the dynamic string. </p>

</div>
</div>
<a id="a1b08e23240c0ddf82dcf069f3fde61bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b08e23240c0ddf82dcf069f3fde61bd">&#9670;&nbsp;</a></span>advance_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void advance_ptr </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytes_to_advance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances the position of a pointer. </p>
<p>This function advances the position of a pointer by a given number of bytes. </p>

</div>
</div>
<a id="a6e0d2c4f1ff21290a6e91538ece132c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0d2c4f1ff21290a6e91538ece132c4">&#9670;&nbsp;</a></span>allocate_sflv_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocate_sflv_array </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for an array of pointers to SFLV structures. </p>
<p>This function allocates memory for an array of pointers to SFLV structures according to the count of elements specified in the root node. The memory for each structure is also allocated and initialized to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root node. The count of the root node is used to determine the number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbc21842284e7153d39958ca97c2da8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc21842284e7153d39958ca97c2da8b">&#9670;&nbsp;</a></span>append_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_char </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a character to the dynamic string. </p>
<p>This function appends a given character to the end of the dynamic string. </p>

</div>
</div>
<a id="ae84809574808f29af561ff2a5b76fba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84809574808f29af561ff2a5b76fba4">&#9670;&nbsp;</a></span>append_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void append_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>append_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a string to the dynamic string. </p>
<p>This function appends a given string to the end of the dynamic string. Before appending, it checks and reallocates memory if necessary. </p>

</div>
</div>
<a id="ad5d254279f4e08699cf3ca9b18ea2cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d254279f4e08699cf3ca9b18ea2cc3">&#9670;&nbsp;</a></span>check_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_realloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>additional_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks and reallocates memory for the dynamic string. </p>
<p>This function checks whether the current capacity of the dynamic string can accommodate the additional length. If not, it reallocates memory to increase the capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>A pointer to the dynamic string. </td></tr>
    <tr><td class="paramname">additional_length</td><td>The additional length that needs to be accommodated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b0f831d096531abbe7a329a57a80e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0f831d096531abbe7a329a57a80e24">&#9670;&nbsp;</a></span>create_dynamic_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structdynamic__string.html">dynamic_string</a>* create_dynamic_string </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new dynamic string. </p>
<p>This function allocates memory for a dynamic string structure</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created dynamic string structure. </dd></dl>

</div>
</div>
<a id="a1651e23462cc0755ba94e0d4673a4ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1651e23462cc0755ba94e0d4673a4ce8">&#9670;&nbsp;</a></span>decode_bej()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structdynamic__string.html">dynamic_string</a>* decode_bej </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>schema_dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>schema_dictionary_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>annotation_dictionary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>annotation_dictionary_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes BEJ data into a string. </p>
<p>This function is the key function in the file, that decodes the given BEJ data using the provided dictionaries. It first parses the BEJ data into a BEJ tree, and then converts this tree into a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the BEJ data. </td></tr>
    <tr><td class="paramname">data_len</td><td>The length of the BEJ data. </td></tr>
    <tr><td class="paramname">schema_dictionary</td><td>A pointer to the schema dictionary. </td></tr>
    <tr><td class="paramname">schema_dictionary_len</td><td>The length of the schema dictionary. </td></tr>
    <tr><td class="paramname">annotation_dictionary</td><td>A pointer to the annotation dictionary. </td></tr>
    <tr><td class="paramname">annotation_dictionary_len</td><td>The length of the annotation dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the dynamic string holding the decoded data. </dd></dl>

</div>
</div>
<a id="ad3527bde59a731fd8c6fa4358caac455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3527bde59a731fd8c6fa4358caac455">&#9670;&nbsp;</a></span>free_sflv_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_sflv_array </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory of an array of pointers to SFLV structures. </p>
<p>This function frees the memory of each SFLV structure and the array of pointers. </p>

</div>
</div>
<a id="a608dc77b7ed16577b157e7bb774537b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608dc77b7ed16577b157e7bb774537b2">&#9670;&nbsp;</a></span>get_key_from_dictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* get_key_from_dictionary </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>schema_dictionary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the key from the dictionary for the given node. </p>
<p>This function reads the sequence number from the node and finds the corresponding key in the schema dictionary using the sequence number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A pointer to the BEJ node. </td></tr>
    <tr><td class="paramname">schema_dictionary</td><td>A pointer to the schema dictionary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the key. </dd></dl>

</div>
</div>
<a id="a11d8ca7465a9dc756c33c2684f4807bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d8ca7465a9dc756c33c2684f4807bc">&#9670;&nbsp;</a></span>parse_bej_node_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parse_bej_node_to_str </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>schema_dictionary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the parsing of the BEJ tree to a string. </p>
<p>This function initializes the parsing of the BEJ tree by starting from the root of the tree. It adds the enclosing braces to the string and calls the recursive function to parse the nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the root of the BEJ tree. </td></tr>
    <tr><td class="paramname">str</td><td>A pointer to the dynamic string. </td></tr>
    <tr><td class="paramname">schema_dictionary</td><td>A pointer to the schema dictionary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64ac21e49ede2df99d05d62778013958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ac21e49ede2df99d05d62778013958">&#9670;&nbsp;</a></span>parse_bej_node_to_str_recursion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parse_bej_node_to_str_recursion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdynamic__string.html">dynamic_string</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>parse_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>recursion_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>schema_dictionary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively parses a BEJ node and its children to a string. </p>
<p>This function recursively parse the BEJ tree and builds a dynamic string. The function distinguishes between different BEJ formats (INTEGER, STRING, ARRAY) and parses them appropriately. For each node, the function appends its key (if present) and value to the dynamic string. In case of ARRAY type, the function recursively processes all child nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A pointer to the current BEJ node. </td></tr>
    <tr><td class="paramname">str</td><td>A pointer to the dynamic string. </td></tr>
    <tr><td class="paramname">parse_type</td><td>The type of parsing required (with or without key). </td></tr>
    <tr><td class="paramname">recursion_depth</td><td>The current depth of recursion. </td></tr>
    <tr><td class="paramname">schema_dictionary</td><td>A pointer to the schema dictionary. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad983441c699b8261b6bc1413a0cd0184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad983441c699b8261b6bc1413a0cd0184">&#9670;&nbsp;</a></span>parse_sflv_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbej__node.html">bej_node</a>* parse_sflv_init </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the parsing of data into a SFLV structure. </p>
<p>This is an initial function to prepare for recursion. Function allocates memory for the root node, advances the data pointer by 12 bytes, reads the count of elements, and then calls parse_sflv_recursion for each child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the data. The position of the data pointer will be modified. </td></tr>
    <tr><td class="paramname">data_len</td><td>The length of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node. </dd></dl>

</div>
</div>
<a id="a512b0358b77851241f832bcbc707103b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512b0358b77851241f832bcbc707103b">&#9670;&nbsp;</a></span>parse_sflv_recursion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbej__node.html">bej_node</a>* parse_sflv_recursion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbej__node.html">bej_node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively parses data into a SFLV structure. </p>
<p>This function will fill all basic fields for bej nodes. For each type, general parameters are filled, but for primitives, a reference to the value is written in the value field, and for complex types, a reference to the next node or several nodes is stored in the value field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A pointer to the parent node. </td></tr>
    <tr><td class="paramname">data</td><td>A double pointer to the data. The position of the data pointer will be modified. </td></tr>
    <tr><td class="paramname">data_len</td><td>The length of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the last node created. </dd></dl>

</div>
</div>
<a id="aa524f98bef13dd63aa015bda5a84c3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa524f98bef13dd63aa015bda5a84c3d6">&#9670;&nbsp;</a></span>read_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_int </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an integer from data. </p>
<p>This function reads an integer of a given length from data and advances the data pointer by the same number of bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A double pointer to the data. The double pointer is needed to allow the pointer to shift after the data is read </td></tr>
    <tr><td class="paramname">length</td><td>The length of the integer to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer value read from the data. </dd></dl>

</div>
</div>
<a id="a54f5c0fbab108d820ddfc5a60ebea2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f5c0fbab108d820ddfc5a60ebea2fa">&#9670;&nbsp;</a></span>read_int_const_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_int_const_ptr </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an integer from data. </p>
<p>This function reads an integer of a given length from data. The position of the data pointer is not modified.</p>
<dl class="section return"><dt>Returns</dt><dd>The integer value read from the data. </dd></dl>

</div>
</div>
<a id="a9a1e449bf8ab0198a1dc7922136510ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1e449bf8ab0198a1dc7922136510ea">&#9670;&nbsp;</a></span>read_length_and_get_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_length_and_get_int </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the length of an integer from data, then reads the integer. </p>
<p>This function first reads a byte from data to determine the length of the integer, then reads the integer of that length from data. The data pointer is advanced by the length of the integer plus one byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A double pointer to the data. The double pointer is needed to allow the pointer to shift after the data is read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integer value read from the data. </dd></dl>

</div>
</div>
<a id="a791b3d5c96b1e9ebeddbcdb992eb0678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b3d5c96b1e9ebeddbcdb992eb0678">&#9670;&nbsp;</a></span>read_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* read_str </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string from data. </p>
<p>This function reads a string of a given length from data and advances the data pointer by the same number of bytes. The string will be null-terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A double pointer to the data. The position of the data pointer will be modified. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the string to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the string read from the data. </dd></dl>

</div>
</div>
<a id="a15dd2a2f04ea263c2e66861676eacde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dd2a2f04ea263c2e66861676eacde5">&#9670;&nbsp;</a></span>read_str_const_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* read_str_const_ptr </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string from data. </p>
<p>This function reads a string of a given length from data. The position of the data pointer is not modified.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the string read from the data. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
