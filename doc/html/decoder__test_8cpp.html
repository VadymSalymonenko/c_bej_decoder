<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MyProject: src/test/decoder_test.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MyProject
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_120ed4da3e3217b1e7fc0b4f48568e79.html">test</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">decoder_test.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;gtest/gtest.h&quot;</code><br />
<code>#include &quot;<a class="el" href="bej__decoder_8h_source.html">../bej_decoder.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for decoder_test.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="decoder__test_8cpp__incl.png" border="0" usemap="#asrc_2test_2decoder__test_8cpp" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a68df6a1c0e7634ba32a66f9f01d4cb6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#a68df6a1c0e7634ba32a66f9f01d4cb6f">TESTING</a></td></tr>
<tr class="separator:a68df6a1c0e7634ba32a66f9f01d4cb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a16240596a4fbfb276b89c199d25f28f8"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#a16240596a4fbfb276b89c199d25f28f8">hex_to_bytes</a> (const char *hex)</td></tr>
<tr class="memdesc:a16240596a4fbfb276b89c199d25f28f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string of hexadecimal digits into an array of bytes. This function iterates through pairs of characters in the input string, converting each pair from a hexadecimal digit to a byte value using sscanf, and storing the resulting bytes in a dynamically allocated array.  <a href="decoder__test_8cpp.html#a16240596a4fbfb276b89c199d25f28f8">More...</a><br /></td></tr>
<tr class="separator:a16240596a4fbfb276b89c199d25f28f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895fbc449ad2e212048b56e21d70b93b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#a895fbc449ad2e212048b56e21d70b93b">read_file</a> (const char *file_path, unsigned char **buffer)</td></tr>
<tr class="memdesc:a895fbc449ad2e212048b56e21d70b93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a file into a buffer.  <a href="decoder__test_8cpp.html#a895fbc449ad2e212048b56e21d70b93b">More...</a><br /></td></tr>
<tr class="separator:a895fbc449ad2e212048b56e21d70b93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f118e4d6c99b3fe374147e685dc44d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#a0f118e4d6c99b3fe374147e685dc44d4">TEST</a> (parse_SFLV_init_test, returns_correct_format)</td></tr>
<tr class="memdesc:a0f118e4d6c99b3fe374147e685dc44d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This test case checks the function 'parse_sflv_init' for the correct decoding of format, count, sequence, and dictionary type fields.  <a href="decoder__test_8cpp.html#a0f118e4d6c99b3fe374147e685dc44d4">More...</a><br /></td></tr>
<tr class="separator:a0f118e4d6c99b3fe374147e685dc44d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89a579d637fced036c1d8e17777c942"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#ac89a579d637fced036c1d8e17777c942">TEST</a> (parse_SFLV_integer_node, returns_correct_format)</td></tr>
<tr class="memdesc:ac89a579d637fced036c1d8e17777c942"><td class="mdescLeft">&#160;</td><td class="mdescRight">This test case checks the function 'parse_sflv_init' for the correct decoding of format, count, sequence, and dictionary type fields.  <a href="decoder__test_8cpp.html#ac89a579d637fced036c1d8e17777c942">More...</a><br /></td></tr>
<tr class="separator:ac89a579d637fced036c1d8e17777c942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01506ecf54bd0b4933c02d7ada569a02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#a01506ecf54bd0b4933c02d7ada569a02">TEST</a> (append_string_test, multiple_appends)</td></tr>
<tr class="memdesc:a01506ecf54bd0b4933c02d7ada569a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This test case checks the 'append_string' function for multiple string appends.  <a href="decoder__test_8cpp.html#a01506ecf54bd0b4933c02d7ada569a02">More...</a><br /></td></tr>
<tr class="separator:a01506ecf54bd0b4933c02d7ada569a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04acd74e44d3666f6c542a3c0564f479"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#a04acd74e44d3666f6c542a3c0564f479">TEST</a> (read_str_test, simple_string)</td></tr>
<tr class="memdesc:a04acd74e44d3666f6c542a3c0564f479"><td class="mdescLeft">&#160;</td><td class="mdescRight">This test case checks the function 'read_str_const_ptr' for a simple string.  <a href="decoder__test_8cpp.html#a04acd74e44d3666f6c542a3c0564f479">More...</a><br /></td></tr>
<tr class="separator:a04acd74e44d3666f6c542a3c0564f479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d4a4efe48ee75b80406e0ceb71e9b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#ae7d4a4efe48ee75b80406e0ceb71e9b6">TEST</a> (read_str_test, empty_string)</td></tr>
<tr class="memdesc:ae7d4a4efe48ee75b80406e0ceb71e9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This test case checks the function 'read_str_const_ptr' for an empty string.  <a href="decoder__test_8cpp.html#ae7d4a4efe48ee75b80406e0ceb71e9b6">More...</a><br /></td></tr>
<tr class="separator:ae7d4a4efe48ee75b80406e0ceb71e9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="decoder__test_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a68df6a1c0e7634ba32a66f9f01d4cb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68df6a1c0e7634ba32a66f9f01d4cb6f">&#9670;&nbsp;</a></span>TESTING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TESTING</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a16240596a4fbfb276b89c199d25f28f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16240596a4fbfb276b89c199d25f28f8">&#9670;&nbsp;</a></span>hex_to_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* hex_to_bytes </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string of hexadecimal digits into an array of bytes. This function iterates through pairs of characters in the input string, converting each pair from a hexadecimal digit to a byte value using sscanf, and storing the resulting bytes in a dynamically allocated array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hex</td><td>A pointer to a null-terminated string containing hexadecimal digits. It is assumed that the string length is even and the string contains only valid hexadecimal digits (0-9, A-F, a-f).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly allocated array of bytes. The length of the array is half the length of the input string. The caller is responsible for freeing this memory when it is no longer needed. </dd></dl>

</div>
</div>
<a id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c04138a5bfe5d72780bb7e82a18e627">&#9670;&nbsp;</a></span>main()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a895fbc449ad2e212048b56e21d70b93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895fbc449ad2e212048b56e21d70b93b">&#9670;&nbsp;</a></span>read_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t read_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a file into a buffer. </p>
<p>This function reads a file and places its content into a buffer. It handles file opening, size determination, memory allocation for the buffer, and file reading. If there is any error during these operations, it will print an error message and exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_path</td><td>The path to the file. </td></tr>
    <tr><td class="paramname">buffer</td><td>The pointer to the buffer to fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the file. </dd></dl>

</div>
</div>
<a id="a01506ecf54bd0b4933c02d7ada569a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01506ecf54bd0b4933c02d7ada569a02">&#9670;&nbsp;</a></span>TEST() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TEST </td>
          <td>(</td>
          <td class="paramtype">append_string_test&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">multiple_appends&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This test case checks the 'append_string' function for multiple string appends. </p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000003">Test:</a></b></dt><dd>append_string_test_multiple_appends </dd></dl>
<p>An initial dynamic string is created with 'create_dynamic_string' and then appended with multiple strings using the 'append_string' function. After each append operation, the test checks if the string has been correctly appended and its length has been updated correctly. The test also checks if the overall string is as expected after each append operation. If the appended string and its length match the expected string and length, the test passes. </p>

</div>
</div>
<a id="a0f118e4d6c99b3fe374147e685dc44d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f118e4d6c99b3fe374147e685dc44d4">&#9670;&nbsp;</a></span>TEST() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TEST </td>
          <td>(</td>
          <td class="paramtype">parse_SFLV_init_test&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">returns_correct_format&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This test case checks the function 'parse_sflv_init' for the correct decoding of format, count, sequence, and dictionary type fields. </p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000001">Test:</a></b></dt><dd>parse_SFLV_init_test_returns_correct_format </dd></dl>
<p>The input data is a hexadecimal string representing an array of bytes. The 'hex_to_bytes' function is used to convert this string into an array of bytes. The function 'parse_sflv_init' is then expected to parse this byte array into a '<a class="el" href="structbej__node.html" title="Represents a single node in the BEJ data.">bej_node</a>' structure. The test checks the 'format', 'count', 'sequence', and 'dictionary_type' fields of the returned structure, comparing them to expected values. If they match, the test passes. </p>

</div>
</div>
<a id="ac89a579d637fced036c1d8e17777c942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89a579d637fced036c1d8e17777c942">&#9670;&nbsp;</a></span>TEST() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TEST </td>
          <td>(</td>
          <td class="paramtype">parse_SFLV_integer_node&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">returns_correct_format&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This test case checks the function 'parse_sflv_init' for the correct decoding of format, count, sequence, and dictionary type fields. </p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000002">Test:</a></b></dt><dd>parse_SFLV_integer_node_returns_correct_format </dd></dl>
<p>The input data is a hexadecimal string representing an array of bytes. The function 'parse_sflv_init' is expected to parse this byte array into a '<a class="el" href="structbej__node.html" title="Represents a single node in the BEJ data.">bej_node</a>' structure. The test checks the 'format', 'count', 'sequence', and 'dictionary_type' fields of the second element of the returned structure, comparing them to expected values. If they match, the test passes. </p>

</div>
</div>
<a id="ae7d4a4efe48ee75b80406e0ceb71e9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d4a4efe48ee75b80406e0ceb71e9b6">&#9670;&nbsp;</a></span>TEST() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TEST </td>
          <td>(</td>
          <td class="paramtype">read_str_test&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">empty_string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This test case checks the function 'read_str_const_ptr' for an empty string. </p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000005">Test:</a></b></dt><dd>read_str_test_empty_string </dd></dl>
<p>The input data is an empty string, encoded as a one-element array of unsigned char containing a null character. The expected output is an empty string. The function is expected to correctly decode the input data and return an empty string. The returned string is compared to the expected output using the 'ASSERT_STREQ' macro. If they match, the test passes. </p>

</div>
</div>
<a id="a04acd74e44d3666f6c542a3c0564f479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04acd74e44d3666f6c542a3c0564f479">&#9670;&nbsp;</a></span>TEST() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TEST </td>
          <td>(</td>
          <td class="paramtype">read_str_test&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">simple_string&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This test case checks the function 'read_str_const_ptr' for a simple string. </p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000004">Test:</a></b></dt><dd>read_str_test_simple_string </dd></dl>
<p>The input data is the string "Hello" encoded as an array of unsigned char. The expected output is the original string "Hello". The function is expected to correctly decode the input data and return the original string. The returned string is compared to the expected output using the 'ASSERT_STREQ' macro. If they match, the test passes. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
